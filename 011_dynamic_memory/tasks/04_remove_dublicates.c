// Дан массив {1,2,3,2,3,3,5,6,5}
// нужно удалить дубликаты и оставить в единственном числе
// результат должен быть {1,2,3,5,6}
// нужна функция,  которая проверит есть ли элемент в массиве
// и вернуть T or F(contains) функция  Find
// 1) Резервируем  массив у которого кол-во элементов
// столько сколько в оригинальном
// 2) Бежим по нашему ориг массиву и проверяем на каждой иттерации,
// если элемент есть в новом массиве через функцию contains,
// то пропускаем, иначе  добавляем

// 1) у тебя есть функция которая проверяет есть ли в массиве число (да/нет)
// 2) тебе нужно удалить дубликаты из оригинального массива
// 3) для этого тебе нужно завести массив в который ты запишешь результат без дубликатов
// 4) возникает вопрос а какого размера будет новый массив
// 4.1) тут нужно понять возможные случаи чтобы оценить размер
// 4.2) если на вход тебе дать массив только из {1,1,1,1,1,1,1,1,}  то на выходе будет массив размера 1 {1}
// 4.3) если на вход дать массив в котором нет дубликатов, то на выходе он и получится {1,2,3,4,5} -> {1,2,3,4,5}
// 4.4) получается что худший случай это когда размер нового массива полностью равен размеру исходного массива
// 4.5) поэтому резервируем память чтобы вместить весь исходный массив
// 5) бежим по исходному массиву
// 6) проверяем если элемент из исходного массива уже есть в новом массиве то пропускаем, если элемента нет то доавляем в массив
// 6.1) тут нужно два индекса i - чтобы бежать по исходному массиву j - чтобы бежать по новому массиву j изменяется только если ты добавляешь элемент в массив

#include <stdio.h>
#include <stdbool.h>
#include "../../library/array_utils.h"
#include <stdlib.h>
/*
Есть оригинальный массив,затем мы создаём пустой массив
 и начинаем идти по оригинальному массиву
  и спрашивать у пустого есть ли у тебя этот элемент
  если нет ,то запиши его в новый массив,если уже записан
*/
bool contains(const int arr[], size_t len, int element)
{
    for (int i = 0; i < len; i++)
    {
        if (arr[i] == element)
        {
            return true;
        }
    }
    return false;
}

int* del_dupl(const int* arr, size_t len_arr, size_t* new_arr_len)
{
    int* result = malloc(len_arr * sizeof(int));
    if (result == NULL)
    {
        return NULL;
    }
    *new_arr_len = 0; 
    for(size_t i = 0; i < len_arr;i++)
    {
        bool is_contains = contains(result,*new_arr_len,arr[i]);
        if(is_contains)
        {
            continue;
        }
        result[*new_arr_len] = arr[i];
        (*new_arr_len)++;
    }
    return result;
   
}

int main()
{
    int arr_1[] = {1, 2, 3, 2, 3, 3, 5, 7, 5};
    int len_arr = sizeof(arr_1) / sizeof(arr_1[0]);
    size_t new_arr_len;
    int* arr_without_dupl = del_dupl(arr_1,len_arr,&new_arr_len);
    if(arr_without_dupl == NULL)
    {
        return 1;
    }
    print_array(arr_1,len_arr);
    print_array(arr_without_dupl,new_arr_len);
    free(arr_without_dupl);
    return 0;
}
